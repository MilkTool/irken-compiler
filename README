
Irken

The Goal:
 A new dialect and implementation of a python-like language that
  supports massively scalable cooperative multi-threading, and
  eventually, erlang-style concurrency.

How: A VM that supports continuations. 'threads' will be built using
 continuations.  The VM will be written in a new high-level language
 ('irken-low') that compiles to C.  Continuations will be available in
 both the target language and the implementation language, and since
 we want to support millions of threads, we cannot use the C stack.
 Our approach is to generate continuation-passing style (CPS) code in
 C.

The Plan:

 1) implement the irken-low compiler.
 2) write a VM for irken-high in irken-low
 3) rewrite the irken-low compiler in irken

Currently, I'm in stage 2 - though about 90% of the work is still in stage 1.

================================================================================

The Python code:

compile.py:
  drives everything.

lisp_reader.py:
  reads scheme forms into an s-expression.
  input: program
  output: s-exp

transform.py:
  converts all derived scheme expressions into the core understood by the compiler.
  input: s-exp
  output: s-exp

lambda_tree.py:
  convert the s-expression into a tree of nodes.
  input: s-exp
  output: node tree

typing.py:
  hindley-milner polymorphic type inference [still in progress]

analyze.py:
  alpha conversion, tree shaker, inliner, some simplification
  input: node tree
  output: node tree

cps.py:
  convert to continuation-passing style, where each continuation is represented
    by a 'register' assignment.
  input: node tree
  output: flattened list of insns
  
backend.py:
  emit C code implementing the cps insns.
  input: insns
  output: a C file

================================================================================

The Scheme/irken-low Code:

lib/*.scm:

  These are considered 'official' library implementations of runtime features.
  core.scm:
    candidates for compiler builtins (i.e., no need to (include "xxx.scm"))
  frb.scm:
    functional red-black trees.  may be used for the symbol table, dicts, etc.
    (based on Okasaki)
  io.scm:
    core unix i/o
  pair.scm:
    lisp lists
  random.scm:
    random(3)
  rbtree.scm:
    red-black tree code from scheme48
  string.scm:
    string support
  symbol:
    lisp/scheme symbols
  vector:
    lisp/scheme vectors (i.e., python lists)

tests/*.scm:
  Currently, these are ad-hoc tests used to verify the compiler features as I
  write them.  Eventually, these will turn into automated tests (like the ones
  in compile.py).

vm/*.scm:
  will hold the VM for the python-like language.
   
================================================================================

Quick usage notes.

python compile.py
 - compile and run all the self-tests which you will find near the end of compile.py

python compile.py -l
 - compile and run only the last test

python compile.py -f tests/tak20.scm
 - compile tests/tak20.scm to
           tests/tak20.c and then
           tests/tak20

python compile.py -f -O tests/tak20.scm
 - compile with "gcc -O3"

python compile.py -f -O tests/tak20.scm -s 0
 - compile with safety level '0'

