
(include "lib/core.scm")
(include "lib/pair.scm")
(include "lib/string.scm")
(include "lib/random.scm")
(include "lib/frb.scm")

(define (n-random n)
  (let loop ((n n)
	     (t (tree:empty)))
    (if (= n 0)
	t
	(loop (- n 1) (tree/insert t < (random) (random))))))

(define (print-spaces n)
  (let loop ((n n))
    (cond ((> n 0)
	   (print-string "  ")
	   (loop (- n 1))))))

(define (print-item k v d)
  (print-spaces d)
  (print k)
  (print-string ":")
  (print v)
  (print-string "\n"))

(define (tree/print n)
  (let p ((n n) (d 0))
    (vcase tree n
      ((:empty) #u)
      ((:red    l r k v) (p l (+ d 1)) (print-item k v d) (p r (+ d 1)))
      ((:purple l r k v) (p l (+ d 1)) (print-item k v d) (p r (+ d 1))))
    ))

(define (print-kv k v)
  (print k)
  (print-string " ")
  (print v)
  (print-string "\n"))

(srandom 314159)

(let ((t (n-random 20))
      (t2 (tree:empty))
      )
  (print-string "inorder:\n")
  (tree/inorder print-kv t)
  (print-string "reverse:\n")
  (tree/reverse print-kv t)
  (set! t (tree/insert t < 1234 5000))
  (printn (tree/member t < 1234))
  (printn (tree/member t < 9999))
  (tree/print t)
  (set! t2 (tree/insert t2 string-<? "howdy" 0))
  (set! t2 (tree/insert t2 string-<? "there" 2))
  (tree/print t2)
  (let ((probe (tree/member t2 string-<? "there")))
    (vcase maybe probe
      ((:no) (printn "nope") #t)
      ((:yes val) (printn val) #t)))
  )
